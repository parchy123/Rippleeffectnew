<resources>
    <string name="app_name">LearnAndroid</string>
    <string name="drawer_opened">Drawerclosed</string>
    <string name="drawer_closed">Drawerclosed</string>

    <string name="navigation_drawer_open">Open navigation drawer</string>
<string name="aboutus">Hello guys this is the app Specially for those guys who want to build beautiful apps for this beautiful world.As we all know apps provides us so many beautiful things that we can\'\t explain.So u should know how to create an app and this is the right Platform for building and Learning how to create an app in android.</string>
    <string name="navigation_drawer_close">Close navigation drawer</string>
<string name="about2">Created By:\nVikas Bajpayee,Navdeep,Vishal Mishra,Sanat Mishra,Gaurav Sharma,Vipin,Aman,Abhishek,Rahul,Shivi,Rohit Gautam,Sachin\nContact me or Report any Bug here.:-</string>
<string name="banner_ad_unit_id">ca-app-pub-3571509120003278/2811713148</string>
    <string name="url">https://github.com/vikashumain</string>
    <string name="syswindow">

Microsoft® Windows® 7/8/10 (32- or 64-bit)\n
2 GB RAM minimum, 8 GB RAM recommended\n
2 GB of available disk space minimum,\n
4 GB Recommended (500 MB for IDE + 1.5 GB for Android SDK and emulator system image)\n
1280 x 800 minimum screen resolution\n
For accelerated emulator: 64-bit operating system and Intel® processor with support for Intel® VT-x, Intel® EM64T (Intel® 64), and Execute Disable (XD) Bit functionality</string>
<string name="andro">1.1.0=first release\n2.1.5=cupcakes(Phones only)\n3.1.6=Donut(phones only)\n4.2.0,2.1=Eclairs(phones only)\n5.2.3=gingerbread(phones only)6.3.0,3.1,3.2=Honeycomb(Tablets only)Linux kernel came from here.\n7.4.0=Icecream sandwich(phones and tablets only)\n8.4.1,4.2,4.3,4.4=Kitkat(phones and tablets both)\n9.5.0,5.1=Honeycomb\n6.0=Marshmallow\n10.7.0=Nogut
</string>

<string name="sysmac">Mac® OS X® 10.8.5 or higher, up to 10.11.4 (El Capitan)\n
2 GB RAM minimum, 8 GB RAM recommended\n
2 GB of available disk space minimum,\n
4 GB Recommended (500 MB for IDE + 1.5 GB for Android SDK and emulator system image)\n
1280 x 800 minimum screen resolution</string>

<string name="syslinux">GNOME or KDE desktop\n
Tested on Ubuntu® 12.04, Precise Pangolin (64-bit distribution capable of running 32-bit applications)\n
64-bit distribution capable of running 32-bit applications\n
GNU C Library (glibc) 2.11 or later\n
2 GB RAM minimum, 8 GB RAM recommended\n
2 GB of available disk space minimum,\n
4 GB Recommended (500 MB for IDE + 1.5 GB for Android SDK and emulator system image)\n
1280 x 800 minimum screen resolution\n
For accelerated emulator: Intel® processor with support for Intel® VT-x, Intel® EM64T (Intel® 64), and Execute Disable (XD) Bit functionality, or AMD processor with support for AMD Virtualization™ (AMD-V™)</string>
    <string name="txt_start_page">Android Quiz</string>

    <string name="str_start_now">Start Now</string>

    <string name="str_next">Next</string>

    <string name="str_done">Done</string>

    <string name="str_results">Results</string>

    <string name="str_gotohome">Go to Home</string>
<string name="urlnew">vikas</string>
    <string name="str_viewans">View Answer</string>
    <string name="overview">Android is an open-source and Linux based Operating system for mobile devices such as smartphones and tablets.Android offers a unified approach to application development for mobile devices which means developers need only develop for Android, and their applications should be able to run on different devices powered by Android.Android was developed by the Open Handset Alliance, led by Google, and other companies.The first beta version of the Android Software Development Kit (SDK) was released by Google in 2007 where as the first commercial version, Android 1.0, was released in September 2008.</string>
    <string name="feature">1.Beautiful ui\n2.Connectivity=GSM/EDGE, IDEN, CDMA, EV-DO, UMTS, Bluetooth, Wi-Fi, LTE, NFC and WiMAX.\n3.Storage=SQLite, a lightweight relational database, is used for data storage purposes.\n4.Media support=H.263, H.264, MPEG-4 SP, AMR, AMR-WB, AAC, HE-AAC, AAC 5.1, MP3, MIDI, Ogg Vorbis, WAV, JPEG, PNG, GIF, and BMP.5.Multitouch\n6.Multitasking\n7.Resizable widgets=Widgets are resizable, so users can expand them to show more content or shrink them to save space.\n8.GCM=Google Cloud Messaging (GCM) is a service that lets developers send short message data to their users on Android devices, without needing a proprietary sync solution.\n9.Multilanguage=Supports single direction and bi-directional text.</string>
<string name="androappli">Android applications are usually developed in the Java language using the Android Software Development Kit. Once developed, Android applications can be packaged easily and sold out either through a store such as Google Play or the Amazon Appstore. Android powers hundreds of millions of mobile devices in more than 190 countries around the world. It\'\s the largest installed base of any mobile platform and growing fast. Every day more than 1 million new Android devices are activated worldwide.</string>
<string name="environ">You will be glad to know that you can start your Android application development on either of the following operating systems:\n  Microsoft Windows XP or later version.\n  Mac OS X 10.5.8 or later version with Intel chip.\n  Linux including GNU C Library 2.7 or later.</string>
<string name="soft">Following is the list of software\'\s you will need before you start your Android application programming.\n  Java JDK5 or JDK6\n  Android SDK\n  Eclipse IDE for Java Developers (optional)\n  Android Development Tools (ADT) Eclipse Plugin (optional)</string>
<string name="compo">Application components are the essential building blocks of an Android application. These components are loosely coupled by the application manifest file AndroidManifest.xml that describes each component of the application and how they interact. There are following four main components that can be used within an Android application:\n1.Activities\n2.Services\n3.Broadcast Receivers\n4.Content Providers</string>
<string name="activity">They dictate the UI and handle the user interaction to the smartphone screen.An activity represents a single screen with a user interface. For example, an email application might have one activity that shows a list of new emails, another activity to compose an email, and another activity for reading emails. If an application has more than one activity, then one of them should be marked as the activity that is presented when the application is launched.An activity is implemented as a subclass of Activity class as follows:\n <b>public class MainActivity extends Activity</b> \n{\n }\n\nyou have seen in C++/C or in Java languages that program starts from main().Similarly android system initiates its program with in an \'\activity\'\ starting with a call on onCreate() callback a method.there is a sequence of callbacks methods that starts up an activity and a sequence of callbacks methods that tear down an activity.the activity class defines the following callbacks i.e. events.we dont need to implement all these methods.</string>
<string name="services">A service is a component that runs in the background to perform long-running operations. For example, a service might play music in the background while the user is in a different application, or it might fetch data over the network without blocking user interaction with an activity. A service is implemented as a subclass of Service class as follows: \n<b>public class MyService extends Service</b> \n{ \n}</string>
<string name="br">Broadcast Receivers simply respond to broadcast messages from other applications or from the system. For example, applications can also initiate broadcasts to let other applications know that some data has been downloaded to the device and is available for them to use, so this is broadcast receiver who will intercept this communication and will initiate appropriate action. A broadcast receiver is implemented as a subclass of BroadcastReceiver class and each message is broadcasted as an Intent object.\n<b> public class MyReceiver extends BroadcastReceiver</b> \n{\n }</string>
<string name="cp">A content provider component supplies data from one application to others on request. Such requests are handled by the methods of the ContentResolver class. The data may be stored in the file system, the database or somewhere else entirely. A content provider is implemented as a subclass of ContentProvider class and must implement a standard set of APIs that enable other applications to perform transactions.\n<b> public class MyContentProvider extends ContentProvider</b>\n { \n}</string>
    <string name="ac">There are additional components which will be used in the construction of above mentioned entities, their logic, and wiring between them. These components are:\nFragments=fragments are a part of an activity if you want to rotate your activity 360 degree then you can use fragments.\nViews=views are a basic building blocks of an activity.ex buttons,textview,editext etc are views.\nManifest file=It defines the fundamental characteristics of an app.it holds the app icons and app name.it defines each of app components.\nResources\nLayouts\nIntents.</string>
<string name="helloworld">Before you start writing your first example using Android SDK, you have to make sure that you have setup your Android development environment properly as explained in Android - Environment Setup tutorial.So let us proceed to write a simple Android Application which will print "Hello World!".Follow the option File -> New ->New Project and finally select Android New Application wizard from the wizard list. Now name your application as HelloWorld.</string>
<string name="resources">There are many more items which you use to build a good Android application. Apart from coding for the application, you take care of various other resources like static content that your code uses, such as bitmaps, colors, layout definitions, user interface strings, animation instructions, and more. These resources are always maintained separately in various sub-directories under res/ directory of the project.</string>
    <string name="abandroid">   Files and Folders Description1.MainActivity.java file=The main activity code is a Java file MainActivity.java. This is the actual application file which ultimately gets converted to a Dalvik executable and runs your application.\n\n2.Manifest file=Whatever component you develop as a part of your application, you must declare all its components in a manifest file called AndroidManifest.xml which resides at the root of the application project directory. This file works as an interface between Android OS and your application, so if you do not declare your component in this file, then it will not be considered by the OS.\n\n3.strings.xml file=The strings.xml file is located in the res/values folder and it contains all the text that your application uses. For example, the names of buttons, labels, default text, and similar types of strings go into this file. This file is responsible for their textual content.\n\n4.R.java file=The gen/com.example.helloworld/R.java file is the glue between the activity Java files likeMainActivity.java and the resources like strings.xml. It is an automatically generated file and you should not modify the content of the R.java file.\n\n5.Layout file=The activity_main.xml is a layout file available in res/layout directory, that is referenced by your application when building its interface. You will modify this file very frequently to change the layout of your application.\n\n6.styles.xml file=A style is defined in an XML resource that is separate from the XML that specifies the layout. This XML file resides under res/values/ directory of your project and will have resources as the root node which is mandatory for the style file. The name of the XML file is arbitrary, but it must use the .xml extension. You can define multiple styles per file using style tag but each style will have its name that uniquely identifies the style. Android style attributes are set using item tag</string>
<string name="resources2">You should place each type of resource in a specific subdirectory of your project\'\s res/ directory. For example, here\'\s the file hierarchy for a simple project:\nMyProject/ \n      src/ \n        MyActivity.java\n\n res\n     / drawable/\n    icon.png \nlayout/\n    activity_main.xml \n info.xml \n\nvalues\n    / strings.xml\n\nThe res/ directory contains all the resources in various subdirectories. Here we have an image resource, two layout resources, and a string resource file.\nanim/\ncolor/\ndrawable/\nmenu/\nxml/\nraw/\nvalues/\nlayout/</string>
<string name="accessresources">During your application development you will need to access defined resources either in your code, or in your layout XML files. Following section explains how to access your resources in both the scenarios:\nACCESSING RESOURCES IN CODE \n When your Android application is compiled, a R class gets generated, which contains resource IDs for all the resources available in your res/ directory. You can use R class to access that resource using sub-directory and resource name or directly resource ID.\n  EXAMPLE: To access res/drawable/myimage.png and set an ImageView you will use following code: \n\n  ImageView imageView = (ImageView) findViewById(R.id.myimageview); \nimageView.setImageResource(R.drawable.myimage); \n\nHere first line of the code make use of R.id.myimageview to get ImageView defined with idmyimageview in a Layout file. Second line of code makes use of R.drawable.myimage to get an image with name myimage available in drawable sub-directory under /res.\n\nExample:\nConsider next example where res/values/strings.xml has following definition:</string>
<string name="archite">Android operating system is a stack of software components which is roughly divided into five sections and four main layers as shown below in the architecture diagram.</string>
<string name="hello2">1.src=This contains the .java source files for your project. By default, it includes an MainActivity.javasource file having an activity class that runs when your app is launched using the app icon.The main activity code is a Java file MainActivity.java. This is the actual application file which ultimately gets converted to a Dalvik executable and runs your application.\n\n2.gen=This contains the .R file, a compiler generated file that references all the resources found in your project. You should not modify this file.\n\n3.bin=This folder contains the Android package files .apk built by the ADT during the build process and everything else needed to run an Android application.\n\n4.res/drawable=this contains all icons,images needed for our application of different densities.\n\n4.res/layout=This is a directory for files that define your app\'\s user interface.\n\n5.res/values=This is a directory for other various XML files that contain a collection of resources, such as strings and colors definitions.\n\n6.AndroidManifest.xml=This is the manifest file which describes the fundamental characteristics of the app and defines each of its components.</string>
<string name="intent">An Android Intent is an object carrying an intent ie. message from one component to another component with in the application or outside the application. The intents can communicate messages among any of the three core components of an application  activities, services, and broadcast receivers. The intent itself, an Intent object, is a passive data structure holding an abstract description of an operation to be performed. For example, let\'\s assume that you have an Activity that needs to launch an email client and sends an email using your Android device. For this purpose, your Activity would send an ACTION_SEND along with appropriate chooser, to the Android Intent Resolver. The specified chooser gives the proper interface for the user to pick how to send your email data.</string>
<string name="intentobject">An Intent object is a bundle of information which is used by the component that receives the intent plus information used by the Android system. An Intent object can contain the following components based on what it is communicating or going to perform:\n\n ACTION \n This is mandatory part of the Intent object and is a string naming the action to be performed or, in the case of broadcast intents, the action that took place and is being reported. The action largely determines how the rest of the intent object is structured . The Intent class defines a number of action constants corresponding to different intents.The action in an Intent object can be set by the setAction() method and read by getAction().\n\n DATA \nThe URI of the data to be acted on and the MIME type of that data. For example, if the action field is ACTION_EDIT, the data field would contain the URI of the document to be displayed for editing. The setData() method specifies data only as a URI, setType() specifies it only as a MIME type, and setDataAndType() specifies it as both a URI and a MIME type. The URI is read by getData() and the type by getType().\n\n CATEGORY \n The category is an optional part of Intent object and it\'\s a string containing additional information about the kind of component that should handle the intent. The addCategory() method places a category in an Intent object, removeCategory() deletes a category previously added, and getCategories() gets the set of all categories currently in the object.\n\n EXTRAS \n This will be in key-value pairs for additional information that should be delivered to the component handling the intent. The extras can be set and read using the putExtras() and getExtras() methods respectively.\n\n FLAGS \n These flags are optional part of Intent object and instruct the Android system how to launch an activity, and how to treat it after it\'\s launched etc.</string>
<string name="intenttype">There are following two types of intents supported by Android till version 4.1. \n\n EXPLICIT INTENTS \n   These intents designate the target component by its name and they are typically used for application internal messages such as an activity starting a subordinate service or launching a sister activity.\n\n // Explicit Intent by specifying its class name\n Intent i = new Intent(this, TargetActivity.class);\n i.putExtra("Key1", "ABC");\n i.putExtra("Key2", "123");\n // Starts TargetActivity\n
startActivity(i);\n\n IMPLICIT INTENTS\n These intents do not name a target and the field for the component name is left blank. Implicit intents are often used to activate components in other applications.\n For example:\n // Implicit Intent by specifying a URI\n Intent i = new Intent(Intent.ACTION_VIEW, Uri.parse("http://www.example.com"));\n // Starts Implicit Activity startActivity(i);\n\n The target component which receives the intent can use the getExtras() method to get the extra data sent by the source component.\n For example:\n // Get bundle object at appropriate place in your code\n Bundle extras = getIntent().getExtras();\n // Extract data using passed keys \n String value1 = extras.getString("Key1");\n String value2 = extras.getString("Key2");</string>
<string name="filters">You have seen how an Intent has been used to call an another activity. Android OS uses filters to pinpoint the set of Activities, Services, and Broadcast receivers that can handle the Intent with help of specified set of action, categories, data scheme associated with an Intent. You will use intent-filter element in the manifest file to list down actions, categories and data types associated with any activity, service, or broadcast receiver.</string>
<string name="envjava">After Installing Java Jdk on your pc.Follow the following steps.Right Click on Mycomputer/ThisPC .Then Click on Advanced system settings.following window will appear</string>
<string name="gra">Wait!!!! gradle is building.\n\n\nAfter sometime Avd is launched.</string>
<string name="lay">it defines how views are laid out in an Activity.</string>
    <string name="lay2">\n\n The basic building block for user interface is a View object which is created from the View class and occupies a rectangular area on the screen and is responsible for drawing and event handling. View is the base class for widgets, which are used to create interactive UI components like buttons, text fields, etc. The ViewGroup is a subclass of View and provides invisible container that hold other Views or other ViewGroups and define their layout properties. At third level we have different layouts which are subclasses of ViewGroup class and a typical layout defines the visual structure for an Android user interface and can be created either at run time usingView/ViewGroup objects or you can declare your layout using simple XML file main_layout.xml which is located in the res/layout folder of your project. This tutorial is more about creating your GUI based on layouts defined in XML file. A layout may contain any type of widgets such as buttons, labels, textboxes, and so on.</string>
<string name="type">\n\n There are number of Layouts provided by Android which you will use in almost all the Android applications to provide different view, look and feel. \n\n\n Layout and Description \n\n 1. Linear Layout: LinearLayout is a view group that aligns all children in a single direction, vertically or horizontally.\n\n 2 Relative Layout: RelativeLayout is a view group that displays child views in relative positions.\n\n 3. Table Layout: TableLayout is a view that groups views into rows and columns.\n\n 4. Absolute Layout: AbsoluteLayout enables you to specify the exact location of its children.\n\n 5. Frame Layout: The FrameLayout is a placeholder on screen that you can use to display a single view.\n\n 6. List View: ListView is a view group that displays a list of scrollable items.\n\n 7. Grid View: GridView is a ViewGroup that displays items in a two-dimensional, scrollable grid.\n\n Here width and height are the dimension of the layout/view which can be specified in terms of dp (Density-independent Pixels), sp ( Scale-independent Pixels), pt ( Points which is 1/72 of an inch), px( Pixels), mm ( Millimeters) and finally in (inches). You can specify width and height with exact measurements but more often, you will use one of these constants to set the width or height:\n\n  android:layout_width=wrap_content tells your view to size itself to the dimensions required by its content.\n\n  android:layout_width=fill_parent tells your view to become as big as its parent view.</string>
<string name="viewsidentify">A view object may have a unique ID assigned to it which will identify the View uniquely within the tree. The syntax for an ID, inside an XML tag is: android:id="@+id/my_button"\n\n Following is a brief description of @ and + signs:\n\n  The at-symbol (@) at the beginning of the string indicates that the XML parser should parse and expand the rest of the ID string and identify it as an ID resource.\n\n  The plus-symbol (+) means that this is a new resource name that must be created and added to our resources. To create an instance of the view object and capture it from the layout, use the following:\n\n Button myButton = (Button) findViewById(R.id.my_button);</string>
<string name="uicont">An Android application user interface is everything that the user can see and interact with. You have learned about the various layouts that you can use to position your views in an activity. This chapter will give you detail on various views. A View is an object that draws something on the screen that the user can interact with and aViewGroup is an object that holds other View (and ViewGroup) objects in order to define the layout of the user interface. You define your layout in an XML file which offers a human-readable structure for the layout, similar to HTML.\n\n\n There are number of UI controls provided by Android that allow you to build the graphical user interface for your app.\n\n\n UI Control  Description\n\n 1 TextView= This control is used to display text to the user.\n\n 2 EditText= EditText is a predefined subclass of TextView that includes rich editing capabilities.\n\n 3 AutoCompleteTextView= The AutoCompleteTextView is a view that is similar to EditText, except that it shows a list of completion suggestions automatically while the user is typing.\n\n 4 Button= A push-button that can be pressed, or clicked, by the user to perform an action.\n\n 5 ImageButton= AbsoluteLayout enables you to specify the exact location of its children.\n\n 6 CheckBox= An on/off switch that can be toggled by the user. You should use checkboxes when presenting users with a group of selectable options that are not mutually exclusive.\n\n 7 ToggleButton= An on/off button with a light indicator.\n\n 8 RadioButton= The RadioButton has two states: either checked or unchecked.\n\n 9 RadioGroup= A RadioGroup is used to group together one or more RadioButtons.\n\n 10 ProgressBar= The ProgressBar view provides visual feedback about some ongoing tasks, such as when you are performing a task in the background.\n\n 11 Spinner= A drop-down list that allows users to select one value from a set.\n\n 12 TimePicker= The TimePicker view enables users to select a time of the day, in either 24-hour mode or AM/PM mode.\n\n 13 DatePicker= The DatePicker view enables users to select a date of the day.</string>
    <string name="title_activity_normal_app_bar_layout">NormalAppBarLayoutActivity</string>

    <string name="title_activity_spring_app_bar_layout">SpringAppBarLayoutActivity</string>

    <string name="title_activity_spring_app_bar_tab_layout">SpringAppBarLayoutTabActivity</string>

    <string name="title_activity_app_bar_fling_layout">AppBarFlingFixTabActivity</string>

    <string name="eve">Events are a useful way to collect data about a user\'\s interaction with interactive components of your app, like button presses or screen touch etc. The Android framework maintains an event queue into which events are placed as they occur and then each event is removed from the queue on a first-in, first-out (FIFO) basis. You can capture these events in your program and take appropriate action as per requirements. There are following three concepts related to Android Event Management:\n  Event Listeners: The View class is mainly involved in building up a Android GUI, same View class provides a number of Event Listeners. The Event Listener is the object that receives notification when an event happes.\n  Event Listeners Registration: Event Registration is the process by which an Event Handler gets registered with an Event Listener so that the handler is called when the Event Listener fires the event. \n Event Handlers: When an event happens and we have registered and event listener fo the event, the event listener calls the Event Handlers, which is the method that actually handles the event.
        \n Events Listener Description OnClickListener()= This is called when the user either clicks or touches or focuses upon any widget like button, text, image etc. You will use onClick() event handler to handle such event.\nOnLongClickListener()= This is called when the user either clicks or touches or focuses upon any widget like button, text, image etc. for one or more seconds. You will use onLongClick() event handler to handle such event.\nOnFocusChangeListener()= This is called when the widget looses its focus ie. user goes away from the view item. You will use onFocusChange() event handler to handle such event.\nOnFocusChangeListener()= This is called when the user is focused on the item and presses or releases a hardware key on the device. You will use onKey() event handler to handle such event.\nOnTouchListener()= This is called when the user presses the key, releases the key, or any movement gesture on the screen. You will use onTouch() event handler to handle such event.\nOnMenuItemClickListener()= This is called when the user selects a menu item. You will use onMenuItemClick() event handler to handle such event. There are many more event listeners available as a part of View class like OnHoverListener, OnDragListener etc which may be needed for your application. So I recommend to refer official documentation for Android application development in case you are going to develop a sophisticated apps. \n\n Event Listeners Registration: Event Registration is the process by which an Event Handler gets registered with an Event Listener so that the handler is called when the Event Listener fires the event. Though there are several tricky ways to register your event listener for any event, but I\'\m going to list down only top 3 ways, out of which you can use any of them based on the situation. \n Using an Anonymous Inner Class \n Activity class implements the Listener interface.\n  Using Layout file activity_main.xml to specify event handler directly.</string>

    <string name="action_settings">Settings</string>
    <string name="sty">If you already know about Cascading Style Sheet (CSS) in web design then to understand Android Style also works very similar way. There are number of attributes associated with each Android widget which you can set to change your application look and feel. A style can specify properties such as height, padding, font color, font size, background color, and much more.</string>
<string name="componen">Android offers a great list of pre-built widgets like Button, TextView, EditText, ListView, CheckBox, RadioButton, Gallery, Spinner, AutoCompleteTextView etc. which you can use directly in your Android application development, but there may be a situation when you are not satisfied with existing functionality of any of the available widgets. Android provides you with means of creating your own custom components which you can customized to suit your needs. If you only need to make small adjustments to an existing widget or layout, you can simply subclass the widget or layout and override its methods which will give you precise control over the appearance and function of a screen element. This tutorial explains you how to create custom Views and use them in your application using simple and easy steps.Creating a Simple Custom Component The simplest way to create your custom component is to extend an existing widget class or subclass with your own class if you want to extend the functionality of existing widget like Button, TextView, EditText, ListView, CheckBox etc. otherwise you can do everything yourself by starting with theandroid.view.View class. At its simplest form you will have to write your constructors corresponding to all the constructors of the base class. For example if you are going to extend TextView to create a DateView then following three constructors will be created for DateView class:
    public class DateView extends TextView
    {
    public DateView(Context context)
    {
    super(context); //--- Additional custom code -- }
    public DateView(Context context, AttributeSet attrs) { super(context, attrs); //--- Additional custom code -
} public DateView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); //--- Additional custom code -- } }</string>
</resources>
